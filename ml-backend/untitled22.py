# -*- coding: utf-8 -*-
"""Untitled22.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15Fp3DpeyzDGIX47r0mBzTbNXbGLYOc3D
"""

import pandas as pd
import numpy as np
import requests
import json
import re
import pickle
from collections import Counter, defaultdict
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import (
    Input, Bidirectional, LSTM, Dense, Dropout,
    MultiHeadAttention, LayerNormalization,
    Concatenate, GlobalAveragePooling1D
)
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau
import nltk
from nltk.tokenize import word_tokenize, sent_tokenize
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
import warnings
warnings.filterwarnings('ignore')

try:
    nltk.data.find('tokenizers/punkt')
    nltk.data.find('corpora/stopwords')
    nltk.data.find('corpora/wordnet')
except LookupError:
    nltk.download('punkt')
    nltk.download('stopwords')
    nltk.download('wordnet')

class DreamBankLoader:
    def __init__(self):
        self.dreams_df = None
        self.processed_dreams = None

    def download_dreambank_data(self):
        try:
            from datasets import load_dataset
            dataset = load_dataset("gustavecortal/DreamBank-annotated", split='train')
            df = dataset.to_pandas()
            self.dreams_df = df
            return df
        except Exception as e:
            print(f"HuggingFace method failed: {str(e)}")

        # Method 2: Try direct download from DreamBank API/website
        try:
            print("Method 2: Attempting direct download from DreamBank...")
            # DreamBank has different series of dreams, we'll try to get multiple
            dream_series = ['barb_sanders', 'mvd', 'b', 'college_women', 'vietnam_vet']
            all_dreams = []

            base_url = "http://www.dreambank.net/random_sample.cgi"

            for series in dream_series:
                try:
                    response = requests.get(f"{base_url}?series={series}&n=100", timeout=10)
                    if response.status_code == 200:
                        # Parse the response (this would need to be adapted based on actual API)
                        print(f"Downloaded data for series: {series}")
                        # Add parsing logic here
                except Exception as series_error:
                    print(f"Failed to download {series}: {str(series_error)}")
                    continue

        except Exception as e:
            print(f"Direct download method failed: {str(e)}")

        # Method 3: Load from local file if available
        try:
            print("Method 3: Looking for local DreamBank file...")
            local_files = ['dreambank.csv', 'dreambank_dreams.json', 'dreams.txt']

            for filename in local_files:
                try:
                    if filename.endswith('.csv'):
                        df = pd.read_csv(filename)
                        print(f"✓ Loaded {len(df)} dreams from {filename}")
                        self.dreams_df = df
                        return df
                    elif filename.endswith('.json'):
                        with open(filename, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                        df = pd.DataFrame(data)
                        print(f"✓ Loaded {len(df)} dreams from {filename}")
                        self.dreams_df = df
                        return df
                except FileNotFoundError:
                    continue
                except Exception as e:
                    print(f"Error reading {filename}: {str(e)}")
                    continue

        except Exception as e:
            print(f"Local file method failed: {str(e)}")
        return None

    def load_dreambank_from_file(self, filepath):
        try:
            if filepath.endswith('.csv'):
                df = pd.read_csv(filepath)
            elif filepath.endswith('.json'):
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                df = pd.DataFrame(data)
            elif filepath.endswith('.txt'):
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                dreams = re.split(r'\n\n+|\*\*\*+|---+', content)
                df = pd.DataFrame({'dream_report': dreams})
            else:
                raise ValueError("Unsupported file format. Use .csv, .json, or .txt")

            print(f"Loaded {len(df)} dreams from {filepath}")
            self.dreams_df = df
            return df

        except Exception as e:
            print(f"Error loading file {filepath}: {str(e)}")
            return None

class DreamBankProcessor:
    def __init__(self, dreams_df):
        self.dreams_df = dreams_df
        self.lemmatizer = WordNetLemmatizer()
        self.stop_words = set(stopwords.words('english'))
        self.processed_dreams = None
        self.dream_categories = None
        self.vectorizer = TfidfVectorizer(max_features=5000, stop_words='english')
        self.dream_vectors = None

    def process_dreams(self):
        processed_dreams = []

        for idx, row in self.dreams_df.iterrows():
            dream_text = ""
            possible_columns = ['dream_report', 'dream', 'text', 'content', 'narrative', 'report']

            for col in possible_columns:
                if col in row and pd.notna(row[col]):
                    dream_text = str(row[col])
                    break

            if not dream_text or len(dream_text.strip()) < 20:
                continue  # Skip very short or empty dreams

            # Clean and process dream text
            clean_text = self.clean_dream_text(dream_text)

            # Extract dream elements
            elements = self.extract_dream_elements(clean_text)

            # Categorize dream mood/emotion
            mood_valence, mood_arousal = self.analyze_dream_mood(clean_text)

            processed_dream = {
                'dream_id': idx,
                'original_text': dream_text,
                'clean_text': clean_text,
                'mood_valence': mood_valence,
                'mood_arousal': mood_arousal,
                'emotions': elements['emotions'],
                'settings': elements['settings'],
                'characters': elements['characters'],
                'objects': elements['objects'],
                'activities': elements['activities'],
                'colors': elements['colors'],
                'themes': elements['themes'],
                'word_count': len(clean_text.split()),
                'series': row.get('series', 'unknown'),
                'dreamer': row.get('dreamer', 'unknown')
            }

            processed_dreams.append(processed_dream)

        self.processed_dreams = pd.DataFrame(processed_dreams)

        # Create TF-IDF vectors for similarity matching
        dream_texts = self.processed_dreams['clean_text'].tolist()
        self.dream_vectors = self.vectorizer.fit_transform(dream_texts)

        print(f"✓ Processed {len(self.processed_dreams)} dreams")
        print(f"✓ Average dream length: {self.processed_dreams['word_count'].mean():.1f} words")

        return self.processed_dreams

    def clean_dream_text(self, text):
        # Remove special characters and normalize whitespace
        text = re.sub(r'[^\w\s\.\,\!\?\:\;]', ' ', text)
        text = re.sub(r'\s+', ' ', text)
        text = text.strip().lower()

        # Remove very common dream report phrases
        remove_phrases = [
            'i had a dream', 'in my dream', 'i dreamed', 'i dreamt',
            'last night i dreamed', 'this dream', 'the dream'
        ]

        for phrase in remove_phrases:
            text = text.replace(phrase, '')

        return text.strip()

    def extract_dream_elements(self, text):

        # Emotion keywords
        emotions = {
            'happy': ['happy', 'joy', 'joyful', 'excited', 'elated', 'cheerful', 'delighted'],
            'fear': ['afraid', 'scared', 'terrified', 'frightened', 'panic', 'terror', 'horror'],
            'sad': ['sad', 'depressed', 'melancholy', 'grief', 'sorrow', 'crying', 'tears'],
            'angry': ['angry', 'furious', 'mad', 'rage', 'irritated', 'frustrated', 'annoyed'],
            'anxious': ['anxious', 'worried', 'nervous', 'stressed', 'tense', 'uneasy'],
            'peaceful': ['calm', 'peaceful', 'serene', 'tranquil', 'relaxed', 'content'],
            'confused': ['confused', 'lost', 'disoriented', 'puzzled', 'bewildered'],
            'excited': ['thrilled', 'ecstatic', 'enthusiastic', 'energetic', 'vibrant']
        }

        # Settings/locations
        settings = {
            'home': ['house', 'home', 'room', 'bedroom', 'kitchen', 'bathroom', 'living room'],
            'school': ['school', 'classroom', 'university', 'college', 'library', 'campus'],
            'work': ['office', 'workplace', 'job', 'meeting', 'conference', 'desk'],
            'nature': ['forest', 'trees', 'mountains', 'hills', 'field', 'garden', 'park'],
            'water': ['ocean', 'sea', 'lake', 'river', 'pool', 'beach', 'swimming'],
            'city': ['city', 'street', 'building', 'downtown', 'urban', 'sidewalk'],
            'transport': ['car', 'bus', 'train', 'plane', 'driving', 'flying', 'traveling']
        }

        # Characters
        characters = {
            'family': ['mother', 'father', 'mom', 'dad', 'sister', 'brother', 'family'],
            'friends': ['friend', 'friends', 'buddy', 'pal', 'companion'],
            'strangers': ['stranger', 'unknown', 'person', 'people', 'someone'],
            'authority': ['teacher', 'boss', 'police', 'doctor', 'professor'],
            'romantic': ['boyfriend', 'girlfriend', 'husband', 'wife', 'partner', 'lover']
        }

        # Activities
        activities = {
            'movement': ['running', 'walking', 'flying', 'swimming', 'dancing', 'jumping'],
            'social': ['talking', 'meeting', 'party', 'gathering', 'conversation'],
            'work': ['working', 'studying', 'writing', 'reading', 'learning'],
            'conflict': ['fighting', 'arguing', 'chasing', 'escaping', 'hiding'],
            'creative': ['playing', 'singing', 'drawing', 'creating', 'performing']
        }

        # Colors
        colors = ['red', 'blue', 'green', 'yellow', 'black', 'white', 'purple',
                 'orange', 'pink', 'brown', 'gray', 'golden', 'silver', 'bright', 'dark']

        # Extract elements
        found_emotions = []
        found_settings = []
        found_characters = []
        found_activities = []
        found_colors = []

        words = text.split()

        # Find emotions
        for emotion_cat, emotion_words in emotions.items():
            for word in emotion_words:
                if word in text:
                    found_emotions.append(emotion_cat)
                    break

        # Find settings
        for setting_cat, setting_words in settings.items():
            for word in setting_words:
                if word in text:
                    found_settings.append(setting_cat)
                    break

        # Find characters
        for char_cat, char_words in characters.items():
            for word in char_words:
                if word in text:
                    found_characters.append(char_cat)
                    break

        # Find activities
        for activity_cat, activity_words in activities.items():
            for word in activity_words:
                if word in text:
                    found_activities.append(activity_cat)
                    break

        # Find colors
        for color in colors:
            if color in text:
                found_colors.append(color)

        # Determine themes based on content
        themes = []
        if any(word in text for word in ['chase', 'run', 'escape', 'follow']):
            themes.append('chase')
        if any(word in text for word in ['fly', 'flying', 'soar', 'float']):
            themes.append('flying')
        if any(word in text for word in ['fall', 'falling', 'drop']):
            themes.append('falling')
        if any(word in text for word in ['test', 'exam', 'grade', 'fail']):
            themes.append('academic')
        if any(word in text for word in ['water', 'swim', 'drown', 'ocean']):
            themes.append('water')

        return {
            'emotions': found_emotions if found_emotions else ['neutral'],
            'settings': found_settings if found_settings else ['unknown'],
            'characters': found_characters if found_characters else ['unknown'],
            'objects': [],
            'activities': found_activities if found_activities else ['observing'],
            'colors': found_colors if found_colors else ['neutral'],
            'themes': themes if themes else ['everyday']
        }

    def analyze_dream_mood(self, text):

        positive_words = ['happy', 'joy', 'love', 'beautiful', 'wonderful', 'amazing',
                         'peaceful', 'calm', 'good', 'great', 'perfect', 'bright']
        negative_words = ['scared', 'afraid', 'sad', 'angry', 'terrible', 'horrible',
                         'dark', 'evil', 'bad', 'wrong', 'ugly', 'frightening']

        high_arousal_words = ['running', 'screaming', 'fighting', 'flying', 'racing',
                             'excited', 'panic', 'intense', 'loud', 'fast']
        low_arousal_words = ['sleeping', 'quiet', 'still', 'calm', 'slow', 'peaceful',
                            'gentle', 'soft', 'relaxed', 'resting']

        # Calculate valence (-1 to 1)
        positive_count = sum(1 for word in positive_words if word in text)
        negative_count = sum(1 for word in negative_words if word in text)

        if positive_count + negative_count == 0:
            valence = 0
        else:
            valence = (positive_count - negative_count) / (positive_count + negative_count)

        # Calculate arousal (-1 to 1)
        high_arousal_count = sum(1 for word in high_arousal_words if word in text)
        low_arousal_count = sum(1 for word in low_arousal_words if word in text)

        if high_arousal_count + low_arousal_count == 0:
            arousal = 0
        else:
            arousal = (high_arousal_count - low_arousal_count) / (high_arousal_count + low_arousal_count)

        return valence, arousal

    def find_similar_dreams(self, target_valence, target_arousal, n_dreams=5):
        if self.processed_dreams is None:
            return []

        # Calculate affect distance
        valence_diff = (self.processed_dreams['mood_valence'] - target_valence) ** 2
        arousal_diff = (self.processed_dreams['mood_arousal'] - target_arousal) ** 2
        affect_distance = np.sqrt(valence_diff + arousal_diff)

        # Get closest dreams
        similar_indices = affect_distance.nsmallest(n_dreams).index
        return self.processed_dreams.iloc[similar_indices]

class BiLSTMDreamPredictor:
    def __init__(self, sequence_length=10, n_features=10):
        self.sequence_length = sequence_length
        self.n_features = n_features
        self.model = None
        self.scaler = StandardScaler()
        self.is_trained = False

    def build_model(self):
        inputs = Input(shape=(self.sequence_length, self.n_features))

        # Bidirectional LSTM layers
        bilstm1 = Bidirectional(LSTM(128, return_sequences=True, dropout=0.2))(inputs)
        bilstm1_norm = LayerNormalization()(bilstm1)

        bilstm2 = Bidirectional(LSTM(64, return_sequences=True, dropout=0.2))(bilstm1_norm)
        bilstm2_norm = LayerNormalization()(bilstm2)

        # Multi-head attention
        attention = MultiHeadAttention(num_heads=8, key_dim=64, dropout=0.1)(bilstm2_norm, bilstm2_norm)
        attention_norm = LayerNormalization()(attention)

        # Combine and pool
        combined = Concatenate()([bilstm2_norm, attention_norm])
        pooled = GlobalAveragePooling1D()(combined)

        # Dense layers
        dense1 = Dense(128, activation='relu')(pooled)
        dropout1 = Dropout(0.3)(dense1)
        dense2 = Dense(64, activation='relu')(dropout1)
        dropout2 = Dropout(0.2)(dense2)

        # Output layer for valence and arousal
        outputs = Dense(2, activation='tanh', name='affect_output')(dropout2)

        self.model = Model(inputs=inputs, outputs=outputs)
        self.model.compile(optimizer=Adam(learning_rate=0.001), loss='mse', metrics=['mae'])

        return self.model

    def prepare_sequences(self, X, y=None):
        X_sequences = []
        y_sequences = [] if y is not None else None

        for i in range(len(X) - self.sequence_length + 1):
            X_sequences.append(X.iloc[i:i+self.sequence_length].values)
            if y is not None:
                y_sequences.append(y.iloc[i+self.sequence_length-1].values)

        return np.array(X_sequences), np.array(y_sequences) if y is not None else None

    def train(self, X, y, epochs=50, batch_size=32):
        # Scale features
        X_scaled = pd.DataFrame(self.scaler.fit_transform(X), columns=X.columns, index=X.index)

        # Prepare sequences
        X_seq, y_seq = self.prepare_sequences(X_scaled, y)

        # Build model if not exists
        if self.model is None:
            self.build_model()

        # Callbacks
        callbacks = [
            EarlyStopping(patience=10, restore_best_weights=True, monitor='val_loss'),
            ReduceLROnPlateau(factor=0.5, patience=5, min_lr=1e-6, monitor='val_loss')
        ]

        # Train
        history = self.model.fit(
            X_seq, y_seq, validation_split=0.2, epochs=epochs,
            batch_size=batch_size, callbacks=callbacks, verbose=1
        )

        self.is_trained = True
        return history

    def predict(self, X):
        X_scaled = pd.DataFrame(self.scaler.transform(X), columns=X.columns, index=X.index)
        X_seq, _ = self.prepare_sequences(X_scaled)
        return self.model.predict(X_seq)

class DreamBankPromptGenerator:
    def __init__(self, dreambank_processor):
        self.dreambank = dreambank_processor

    def generate_prompt_from_affect(self, valence, arousal, physiology_dict):
        # Find similar dreams from DreamBank
        similar_dreams = self.dreambank.find_similar_dreams(valence, arousal, n_dreams=3)

        if len(similar_dreams) == 0:
            return self.generate_fallback_prompt(valence, arousal, physiology_dict)

        # Extract elements from similar dreams
        all_elements = {
            'emotions': [],
            'settings': [],
            'characters': [],
            'activities': [],
            'colors': [],
            'themes': []
        }

        example_texts = []

        for _, dream in similar_dreams.iterrows():
            # Collect elements
            for key in all_elements.keys():
                all_elements[key].extend(dream[key])

            # Collect example text snippets
            text = dream['clean_text']
            if len(text) > 100:
                example_texts.append(text[:200] + "...")

        # Get top elements
        top_elements = {}
        for key, values in all_elements.items():
            if values:
                counter = Counter(values)
                top_elements[key] = [item[0] for item in counter.most_common(3)]
            else:
                top_elements[key] = ['neutral']

        # Determine visual style based on affect
        if valence > 0.3 and arousal > 0.3:
            style = "bright, vivid, energetic, joyful atmosphere"
            colors = "vibrant colors, warm lighting, golden tones"
        elif valence > 0.3 and arousal < -0.3:
            style = "peaceful, serene, harmonious, gentle atmosphere"
            colors = "soft pastels, natural lighting, calming tones"
        elif valence < -0.3 and arousal > 0.3:
            style = "dramatic, intense, dynamic, high-contrast atmosphere"
            colors = "bold colors, sharp contrasts, dramatic lighting"
        elif valence < -0.3 and arousal < -0.3:
            style = "melancholic, subdued, introspective, quiet atmosphere"
            colors = "muted colors, soft shadows, twilight tones"
        else:
            style = "balanced, realistic, everyday atmosphere"
            colors = "natural color palette, even lighting"

        # Generate comprehensive prompt
        prompt = f"""=== DREAMBANK-INSPIRED VISUAL PROMPT ===

CORE DREAM NARRATIVE (from DreamBank):
Based on similar dreams with valence={valence:.3f}, arousal={arousal:.3f}

EXTRACTED ELEMENTS:
• Primary Emotions: {', '.join(top_elements['emotions'][:3])}
• Settings/Locations: {', '.join(top_elements['settings'][:3])}
• Characters: {', '.join(top_elements['characters'][:2])}
• Key Activities: {', '.join(top_elements['activities'][:2])}
• Dominant Themes: {', '.join(top_elements['themes'][:2])}

VISUAL STYLE:
• Atmosphere: {style}
• Color Palette: {colors}
• Mood: {"Positive" if valence > 0 else "Negative"}, {"High Energy" if arousal > 0 else "Low Energy"}

PHYSIOLOGICAL INFLUENCES:
• REM Activity: {physiology_dict.get('rem_bursts', 0):.1f}
• Heart Rate: {physiology_dict.get('heart_rate_bpm', 70):.1f} bpm
• Brain Waves: Gamma {physiology_dict.get('eeg_gamma_power', 0):.3f}

EXAMPLE DREAMBANK EXCERPTS:
{chr(10).join([f"• {text[:100]}..." for text in example_texts[:2]])}

FINAL IMAGE PROMPT:
Create a dreamlike scene featuring {', '.join(top_elements['settings'][:2])} with {', '.join(top_elements['characters'][:2])}.
The scene shows {', '.join(top_elements['activities'][:2])} with an overall {style}.
Use {colors} and convey emotions of {', '.join(top_elements['emotions'][:2])}.
Style: surreal, dreamlike, cinematic, high detail, photographic quality
Themes: {', '.join(top_elements['themes'][:2])}
"""

        return prompt
    def generate_fallback_prompt(self, valence, arousal, physiology_dict):
        return f"""=== FALLBACK DREAM PROMPT ===
Predicted Affect: Valence={valence:.3f}, Arousal={arousal:.3f}
Create a dreamlike scene reflecting the emotional state.
REM: {physiology_dict.get('rem_bursts', 0):.1f}, HR: {physiology_dict.get('heart_rate_bpm', 70):.1f}
Style: surreal, atmospheric, dream photography"""

class CompleteDreamSystem:
    def __init__(self):
        self.physiological_df = None
        self.dreambank_loader = None
        self.dreambank_processor = None
        self.bilstm_model = None
        self.prompt_generator = None
        self.physiology_features = []

    def initialize_system(self, physiological_data_path):
        self.physiological_df = pd.read_csv(physiological_data_path)
        object_columns = ['valence', 'arousal']
        for col in object_columns:
            if col in self.physiological_df.columns:
                self.physiological_df[col] = self.physiological_df[col].astype(str).str.lower().str.strip()
                mapping = {
                    'low': 0, 'medium': 1, 'high': 2,
                    'negative': -1, 'neutral': 0, 'positive': 1,
                    'calm': 0, 'aroused': 1,
                }
                self.physiological_df[col] = self.physiological_df[col].replace(mapping)
                self.physiological_df[col] = pd.to_numeric(self.physiological_df[col], errors='coerce')

        self.physiological_df = self.physiological_df.fillna(self.physiological_df.median(numeric_only=True))
        print(f"Loaded {len(self.physiological_df)} physiological records")

        # 2. Load DreamBank dataset
        self.dreambank_loader = DreamBankLoader()
        dreambank_df = self.dreambank_loader.download_dreambank_data()

        if dreambank_df is None:
            print("Failed")
            return False

        # 3. Process DreamBank dreams
        self.dreambank_processor = DreamBankProcessor(dreambank_df)
        self.dreambank_processor.process_dreams()

        # 4. Initialize BiLSTM model
        self.physiology_features = [
            'eeg_theta_power', 'eeg_gamma_power', 'eeg_delta_power',
            'heart_rate_bpm', 'hrv_ms', 'rem_bursts', 'chin_emg',
            'respiration_rate', 'resp_irregularity', 'skin_conductance'
        ]

        available_features = [col for col in self.physiology_features if col in self.physiological_df.columns]
        self.physiology_features = available_features

        self.bilstm_model = BiLSTMDreamPredictor(
            sequence_length=10,
            n_features=len(available_features)
        )

        # 5. Initialize prompt generator
        self.prompt_generator = DreamBankPromptGenerator(self.dreambank_processor)

        print(f"System initialized with {len(available_features)} physiological features")
        print(f"DreamBank contains {len(self.dreambank_processor.processed_dreams)} processed dreams")

        return True

    def train_system(self, epochs=50, batch_size=32):
        # Prepare training data
        X = self.physiological_df[self.physiology_features].apply(pd.to_numeric, errors='coerce').fillna(0)
        y = self.physiological_df[['valence', 'arousal']].apply(pd.to_numeric, errors='coerce').fillna(0)

        print(f"Training data shape: X={X.shape}, y={y.shape}")

        # Train the model
        history = self.bilstm_model.train(X, y, epochs=epochs, batch_size=batch_size)

        # Evaluate model
        X_scaled = pd.DataFrame(
            self.bilstm_model.scaler.transform(X),
            columns=X.columns, index=X.index
        )
        X_seq, y_seq = self.bilstm_model.prepare_sequences(X_scaled, y)
        X_train, X_test, y_train, y_test = train_test_split(X_seq, y_seq, test_size=0.2, random_state=42)

        predictions = self.bilstm_model.model.predict(X_test)

        for i, target in enumerate(['valence', 'arousal']):
            mse = mean_squared_error(y_test[:, i], predictions[:, i])
            r2 = r2_score(y_test[:, i], predictions[:, i])
            print(f"{target}: MSE={mse:.4f}, R2={r2:.4f}")

        return history

    def generate_dreambank_prompt(self, physiology_sequence):

        # Predict affect from physiology
        predicted_affect = self.bilstm_model.predict(physiology_sequence.reshape(1, -1, len(self.physiology_features)))
        valence, arousal = predicted_affect[0][0], predicted_affect[0][1]

        # Create physiology dictionary
        physiology_dict = dict(zip(self.physiology_features, physiology_sequence[-1]))

        # Generate prompt using DreamBank
        dream_prompt = self.prompt_generator.generate_prompt_from_affect(valence, arousal, physiology_dict)

        return {
            'predicted_valence': valence,
            'predicted_arousal': arousal,
            'physiology_features': physiology_dict,
            'dreambank_prompt': dream_prompt
        }

    def analyze_dreambank_coverage(self):


        dreams = self.dreambank_processor.processed_dreams

        print(f"Total dreams processed: {len(dreams)}")
        print(f"Average valence: {dreams['mood_valence'].mean():.3f} (std: {dreams['mood_valence'].std():.3f})")
        print(f"Average arousal: {dreams['mood_arousal'].mean():.3f} (std: {dreams['mood_arousal'].std():.3f})")

        # Quadrant analysis
        quadrants = {
            'High Valence, High Arousal': ((dreams['mood_valence'] > 0.2) & (dreams['mood_arousal'] > 0.2)).sum(),
            'High Valence, Low Arousal': ((dreams['mood_valence'] > 0.2) & (dreams['mood_arousal'] < -0.2)).sum(),
            'Low Valence, High Arousal': ((dreams['mood_valence'] < -0.2) & (dreams['mood_arousal'] > 0.2)).sum(),
            'Low Valence, Low Arousal': ((dreams['mood_valence'] < -0.2) & (dreams['mood_arousal'] < -0.2)).sum(),
            'Neutral': ((abs(dreams['mood_valence']) <= 0.2) & (abs(dreams['mood_arousal']) <= 0.2)).sum()
        }

        print("\nDream distribution by affect quadrants:")
        for quadrant, count in quadrants.items():
            percentage = (count / len(dreams)) * 100
            print(f"  {quadrant}: {count} dreams ({percentage:.1f}%)")

        # Most common elements
        print("\nMost common dream elements:")
        all_emotions = []
        all_settings = []
        all_themes = []

        for _, dream in dreams.iterrows():
            all_emotions.extend(dream['emotions'])
            all_settings.extend(dream['settings'])
            all_themes.extend(dream['themes'])

        print("  Top emotions:", [item[0] for item in Counter(all_emotions).most_common(5)])
        print("  Top settings:", [item[0] for item in Counter(all_settings).most_common(5)])
        print("  Top themes:", [item[0] for item in Counter(all_themes).most_common(5)])

    def save_system(self, filepath="dreambank_bilstm_system.pkl"):
        save_data = {
            'model_weights': self.bilstm_model.model.get_weights() if self.bilstm_model.model else None,
            'scaler': self.bilstm_model.scaler,
            'physiology_features': self.physiology_features,
            'processed_dreams': self.dreambank_processor.processed_dreams,
            'dream_vectors': self.dreambank_processor.dream_vectors,
            'vectorizer': self.dreambank_processor.vectorizer,
            'is_trained': self.bilstm_model.is_trained
        }

        with open(filepath, 'wb') as f:
            pickle.dump(save_data, f)

def generate_sample_scripts(dream_system, n_samples=5):
    # Prepare test data
    X = dream_system.physiological_df[dream_system.physiology_features].apply(pd.to_numeric, errors='coerce').fillna(0)
    X_scaled = pd.DataFrame(
        dream_system.bilstm_model.scaler.transform(X),
        columns=X.columns, index=X.index
    )
    X_seq, _ = dream_system.bilstm_model.prepare_sequences(X_scaled)

    sample_scripts = []

    for i in range(min(n_samples, len(X_seq))):
        sample_sequence = X_seq[i]

        # Convert back to original scale for interpretation
        sample_orig = dream_system.bilstm_model.scaler.inverse_transform(
            sample_sequence.reshape(-1, len(dream_system.physiology_features))
        ).reshape(sample_sequence.shape)

        # Generate prompt
        result = dream_system.generate_dreambank_prompt(sample_orig)

        sample_scripts.append({
            'sample_id': i + 1,
            'valence': result['predicted_valence'],
            'arousal': result['predicted_arousal'],
            'physiology': result['physiology_features'],
            'prompt': result['dreambank_prompt']
        })

    return sample_scripts

def save_dreambank_scripts(scripts, filename="dreambank_generated_prompts.txt"):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\n")
        f.write("=" * 80 + "\n\n")

        for script_data in scripts:
            f.write(f"DREAM PROMPT #{script_data['sample_id']}\n")
            f.write("-" * 60 + "\n")
            f.write(f"Predicted Affect: Valence={script_data['valence']:.3f}, Arousal={script_data['arousal']:.3f}\n")
            f.write(f"Key Physiology: REM={script_data['physiology'].get('rem_bursts', 0):.1f}, ")
            f.write(f"HR={script_data['physiology'].get('heart_rate_bpm', 70):.1f}bpm\n")
            f.write("-" * 60 + "\n\n")
            f.write(script_data['prompt'])
            f.write("\n" + "=" * 80 + "\n\n")
    return filename

def main():
    print("=" * 60)

    # Initialize system
    dream_system = CompleteDreamSystem()

    physiological_data_path = "dreamwave_synthetic_sleep1.csv"

    success = dream_system.initialize_system(physiological_data_path)

    if not success:
        print("failed!")
        return None

    # Analyze DreamBank coverage
    dream_system.analyze_dreambank_coverage()

    # Train the BiLSTM model
    print("\n" + "=" * 60)
    history = dream_system.train_system(epochs=50, batch_size=32)

    # Generate sample scripts
    print("\n" + "=" * 60)
    sample_scripts = generate_sample_scripts(dream_system, n_samples=5)

    # Save scripts
    script_filename = save_dreambank_scripts(sample_scripts)

    # Save complete system
    dream_system.save_system("dreambank_bilstm_system.pkl")
    return dream_system, sample_scripts

def load_custom_dreambank(filepath):
    dream_system = CompleteDreamSystem()
    dream_system.dreambank_loader = DreamBankLoader()

    dreambank_df = dream_system.dreambank_loader.load_dreambank_from_file(filepath)

    if dreambank_df is not None:
        dream_system.dreambank_processor = DreamBankProcessor(dreambank_df)
        dream_system.dreambank_processor.process_dreams()
        return dream_system
    else:
        print("Failed to load custom DreamBank file")
        return None

def interactive_prompt_generation(dream_system):
    if not dream_system.bilstm_model.is_trained:
        return
    print("Enter physiological values or 'quit' to exit")

    while True:
        try:
            user_input = input("\nEnter 'random' for random values or 'quit': ").strip().lower()

            if user_input == 'quit':
                break
            elif user_input == 'random':
                # Generate random physiological sequence
                n_features = len(dream_system.physiology_features)
                sequence_length = 10

                # Create realistic random values
                random_sequence = np.random.randn(sequence_length, n_features)
                random_sequence[:, 0] *= 0.5  # EEG theta
                random_sequence[:, 1] *= 0.3  # EEG gamma
                random_sequence[:, 3] = 70 + random_sequence[:, 3] * 15  # Heart rate around 70

                result = dream_system.generate_dreambank_prompt(random_sequence)

                print(f"\nGenerated Dream Prompt:")
                print(f"Valence: {result['predicted_valence']:.3f}")
                print(f"Arousal: {result['predicted_arousal']:.3f}")
                print("\n" + "="*50)
                print(result['dreambank_prompt'][:500] + "\n[... truncated ...]")
                print("="*50)
            else:
                print("Please enter 'random' or 'quit'")

        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"Error: {str(e)}")

    print("Interactive session ended")

if __name__ == "__main__":
    dream_system, sample_scripts = main()

    if dream_system and sample_scripts:
        print("\n" + "="*60)
        interactive_choice = input("Run interactive prompt generation? (y/n): ").strip().lower()
        if interactive_choice == 'y':
            interactive_prompt_generation(dream_system)

        print("\nThank you for using the DreamBank-BiLSTM Dream Generation System!")
    else:
        print("\n System failed to initialize. Please check your datasets.")

import pandas as pd
import numpy as np
import requests
import json
import re
import pickle
from collections import Counter, defaultdict
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import (
    Input, Bidirectional, LSTM, Dense, Dropout,
    MultiHeadAttention, LayerNormalization,
    Concatenate, GlobalAveragePooling1D
)
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau
import nltk
from nltk.tokenize import word_tokenize, sent_tokenize
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
import warnings
warnings.filterwarnings('ignore')

# Download NLTK data
try:
    nltk.data.find('tokenizers/punkt')
    nltk.data.find('corpora/stopwords')
    nltk.data.find('corpora/wordnet')
except LookupError:
    nltk.download('punkt')
    nltk.download('stopwords')
    nltk.download('wordnet')

class DreamBankLoader:
    def __init__(self):
        self.dreams_df = None
        self.processed_dreams = None

    def download_dreambank_data(self):
        try:
            from datasets import load_dataset
            dataset = load_dataset("gustavecortal/DreamBank-annotated", split='train')
            df = dataset.to_pandas()
            self.dreams_df = df
            return df
        except Exception as e:
            print(f"HuggingFace method failed: {str(e)}")

        # Method 2: Try direct download from DreamBank API/website
        try:
            print("Method 2: Attempting direct download from DreamBank...")
            # DreamBank has different series of dreams, we'll try to get multiple
            dream_series = ['barb_sanders', 'mvd', 'b', 'college_women', 'vietnam_vet']
            all_dreams = []

            base_url = "http://www.dreambank.net/random_sample.cgi"

            for series in dream_series:
                try:
                    response = requests.get(f"{base_url}?series={series}&n=100", timeout=10)
                    if response.status_code == 200:
                        # Parse the response (this would need to be adapted based on actual API)
                        print(f"Downloaded data for series: {series}")
                        # Add parsing logic here
                except Exception as series_error:
                    print(f"Failed to download {series}: {str(series_error)}")
                    continue

        except Exception as e:
            print(f"Direct download method failed: {str(e)}")

        # Method 3: Load from local file if available
        try:
            print("Method 3: Looking for local DreamBank file...")
            local_files = ['dreambank.csv', 'dreambank_dreams.json', 'dreams.txt']

            for filename in local_files:
                try:
                    if filename.endswith('.csv'):
                        df = pd.read_csv(filename)
                        print(f"✓ Loaded {len(df)} dreams from {filename}")
                        self.dreams_df = df
                        return df
                    elif filename.endswith('.json'):
                        with open(filename, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                        df = pd.DataFrame(data)
                        print(f"✓ Loaded {len(df)} dreams from {filename}")
                        self.dreams_df = df
                        return df
                except FileNotFoundError:
                    continue
                except Exception as e:
                    print(f"Error reading {filename}: {str(e)}")
                    continue

        except Exception as e:
            print(f"Local file method failed: {str(e)}")
            return None

    def load_dreambank_from_file(self, filepath):
        try:
            if filepath.endswith('.csv'):
                df = pd.read_csv(filepath)
            elif filepath.endswith('.json'):
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                df = pd.DataFrame(data)
            elif filepath.endswith('.txt'):
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                dreams = re.split(r'\n\n+|\*\*\*+|---+', content)
                df = pd.DataFrame({'dream_report': dreams})
            else:
                raise ValueError("Unsupported file format. Use .csv, .json, or .txt")

            print(f"Loaded {len(df)} dreams from {filepath}")
            self.dreams_df = df
            return df

        except Exception as e:
            print(f"Error loading file {filepath}: {str(e)}")
            return None

class DreamBankProcessor:
    def __init__(self, dreams_df):
        self.dreams_df = dreams_df
        self.lemmatizer = WordNetLemmatizer()
        self.stop_words = set(stopwords.words('english'))
        self.processed_dreams = None
        self.dream_categories = None
        self.vectorizer = TfidfVectorizer(max_features=5000, stop_words='english')
        self.dream_vectors = None

    def process_dreams(self):
        processed_dreams = []

        for idx, row in self.dreams_df.iterrows():
            dream_text = ""
            possible_columns = ['dream_report', 'dream', 'text', 'content', 'narrative', 'report']

            for col in possible_columns:
                if col in row and pd.notna(row[col]):
                    dream_text = str(row[col])
                    break

            if not dream_text or len(dream_text.strip()) < 20:
                continue # Skip very short or empty dreams

            # Clean and process dream text
            clean_text = self.clean_dream_text(dream_text)

            # Extract dream elements
            elements = self.extract_dream_elements(clean_text)

            # Categorize dream mood/emotion
            mood_valence, mood_arousal = self.analyze_dream_mood(clean_text)

            processed_dream = {
                'dream_id': idx,
                'original_text': dream_text,
                'clean_text': clean_text,
                'mood_valence': mood_valence,
                'mood_arousal': mood_arousal,
                'emotions': elements['emotions'],
                'settings': elements['settings'],
                'characters': elements['characters'],
                'objects': elements['objects'],
                'activities': elements['activities'],
                'colors': elements['colors'],
                'themes': elements['themes'],
                'word_count': len(clean_text.split()),
                'series': row.get('series', 'unknown'),
                'dreamer': row.get('dreamer', 'unknown')
            }

            processed_dreams.append(processed_dream)

        self.processed_dreams = pd.DataFrame(processed_dreams)

        # Create TF-IDF vectors for similarity matching
        dream_texts = self.processed_dreams['clean_text'].tolist()
        self.dream_vectors = self.vectorizer.fit_transform(dream_texts)

        print(f"✓ Processed {len(self.processed_dreams)} dreams")
        print(f"✓ Average dream length: {self.processed_dreams['word_count'].mean():.1f} words")

        return self.processed_dreams

    def clean_dream_text(self, text):
        # Remove special characters and normalize whitespace
        text = re.sub(r'[^\w\s\.\,\!\?\:\;]', ' ', text)
        text = re.sub(r'\s+', ' ', text)
        text = text.strip().lower()

        # Remove very common dream report phrases
        remove_phrases = [
            'i had a dream', 'in my dream', 'i dreamed', 'i dreamt',
            'last night i dreamed', 'this dream', 'the dream'
        ]

        for phrase in remove_phrases:
            text = text.replace(phrase, '')

        return text.strip()

    def extract_dream_elements(self, text):

        # Emotion keywords
        emotions = {
            'happy': ['happy', 'joy', 'joyful', 'excited', 'elated', 'cheerful', 'delighted'],
            'fear': ['afraid', 'scared', 'terrified', 'frightened', 'panic', 'terror', 'horror'],
            'sad': ['sad', 'depressed', 'melancholy', 'grief', 'sorrow', 'crying', 'tears'],
            'angry': ['angry', 'furious', 'mad', 'rage', 'irritated', 'frustrated', 'annoyed'],
            'anxious': ['anxious', 'worried', 'nervous', 'stressed', 'tense', 'uneasy'],
            'peaceful': ['calm', 'peaceful', 'serene', 'tranquil', 'relaxed', 'content'],
            'confused': ['confused', 'lost', 'disoriented', 'puzzled', 'bewildered'],
            'excited': ['thrilled', 'ecstatic', 'enthusiastic', 'energetic', 'vibrant']
        }

        # Settings/locations
        settings = {
            'home': ['house', 'home', 'room', 'bedroom', 'kitchen', 'bathroom', 'living room'],
            'school': ['school', 'classroom', 'university', 'college', 'library', 'campus'],
            'work': ['office', 'workplace', 'job', 'meeting', 'conference', 'desk'],
            'nature': ['forest', 'trees', 'mountains', 'hills', 'field', 'garden', 'park'],
            'water': ['ocean', 'sea', 'lake', 'river', 'pool', 'beach', 'swimming'],
            'city': ['city', 'street', 'building', 'downtown', 'urban', 'sidewalk'],
            'transport': ['car', 'bus', 'train', 'plane', 'driving', 'flying', 'traveling']
        }

        # Characters
        characters = {
            'family': ['mother', 'father', 'mom', 'dad', 'sister', 'brother', 'family'],
            'friends': ['friend', 'friends', 'buddy', 'pal', 'companion'],
            'strangers': ['stranger', 'unknown', 'person', 'people', 'someone'],
            'authority': ['teacher', 'boss', 'police', 'doctor', 'professor'],
            'romantic': ['boyfriend', 'girlfriend', 'husband', 'wife', 'partner', 'lover']
        }

        # Activities
        activities = {
            'movement': ['running', 'walking', 'flying', 'swimming', 'dancing', 'jumping'],
            'social': ['talking', 'meeting', 'party', 'gathering', 'conversation'],
            'work': ['working', 'studying', 'writing', 'reading', 'learning'],
            'conflict': ['fighting', 'arguing', 'chasing', 'escaping', 'hiding'],
            'creative': ['playing', 'singing', 'drawing', 'creating', 'performing']
        }

        # Colors
        colors = ['red', 'blue', 'green', 'yellow', 'black', 'white', 'purple',
                  'orange', 'pink', 'brown', 'gray', 'golden', 'silver', 'bright', 'dark']

        # Extract elements
        found_emotions = []
        found_settings = []
        found_characters = []
        found_activities = []
        found_colors = []

        words = text.split()

        # Find emotions
        for emotion_cat, emotion_words in emotions.items():
            for word in emotion_words:
                if word in text:
                    found_emotions.append(emotion_cat)
                    break

        # Find settings
        for setting_cat, setting_words in settings.items():
            for word in setting_words:
                if word in text:
                    found_settings.append(setting_cat)
                    break

        # Find characters
        for char_cat, char_words in characters.items():
            for word in char_words:
                if word in text:
                    found_characters.append(char_cat)
                    break

        # Find activities
        for activity_cat, activity_words in activities.items():
            for word in activity_words:
                if word in text:
                    found_activities.append(activity_cat)
                    break

        # Find colors
        for color in colors:
            if color in text:
                found_colors.append(color)

        # Determine themes based on content
        themes = []
        if any(word in text for word in ['chase', 'run', 'escape', 'follow']):
            themes.append('chase')
        if any(word in text for word in ['fly', 'flying', 'soar', 'float']):
            themes.append('flying')
        if any(word in text for word in ['fall', 'falling', 'drop']):
            themes.append('falling')
        if any(word in text for word in ['test', 'exam', 'grade', 'fail']):
            themes.append('academic')
        if any(word in text for word in ['water', 'swim', 'drown', 'ocean']):
            themes.append('water')

        return {
            'emotions': found_emotions if found_emotions else ['neutral'],
            'settings': found_settings if found_settings else ['unknown'],
            'characters': found_characters if found_characters else ['unknown'],
            'objects': [],
            'activities': found_activities if found_activities else ['observing'],
            'colors': found_colors if found_colors else ['neutral'],
            'themes': themes if themes else ['everyday']
        }

    def analyze_dream_mood(self, text):

        positive_words = ['happy', 'joy', 'love', 'beautiful', 'wonderful', 'amazing',
                          'peaceful', 'calm', 'good', 'great', 'perfect', 'bright']
        negative_words = ['scared', 'afraid', 'sad', 'angry', 'terrible', 'horrible',
                          'dark', 'evil', 'bad', 'wrong', 'ugly', 'frightening']

        high_arousal_words = ['running', 'screaming', 'fighting', 'flying', 'racing',
                              'excited', 'panic', 'intense', 'loud', 'fast']
        low_arousal_words = ['sleeping', 'quiet', 'still', 'calm', 'slow', 'peaceful',
                             'gentle', 'soft', 'relaxed', 'resting']

        # Calculate valence (-1 to 1)
        positive_count = sum(1 for word in positive_words if word in text)
        negative_count = sum(1 for word in negative_words if word in text)

        if positive_count + negative_count == 0:
            valence = 0
        else:
            valence = (positive_count - negative_count) / (positive_count + negative_count)

        # Calculate arousal (-1 to 1)
        high_arousal_count = sum(1 for word in high_arousal_words if word in text)
        low_arousal_count = sum(1 for word in low_arousal_words if word in text)

        if high_arousal_count + low_arousal_count == 0:
            arousal = 0
        else:
            arousal = (high_arousal_count - low_arousal_count) / (high_arousal_count + low_arousal_count)

        return valence, arousal

    def find_similar_dreams(self, target_valence, target_arousal, n_dreams=5):
        if self.processed_dreams is None:
            return []

        # Calculate affect distance
        valence_diff = (self.processed_dreams['mood_valence'] - target_valence) ** 2
        arousal_diff = (self.processed_dreams['mood_arousal'] - target_arousal) ** 2
        affect_distance = np.sqrt(valence_diff + arousal_diff)

        # Get closest dreams
        similar_indices = affect_distance.nsmallest(n_dreams).index
        return self.processed_dreams.iloc[similar_indices]

class BiLSTMDreamPredictor:
    def __init__(self, sequence_length=10, n_features=10):
        self.sequence_length = sequence_length
        self.n_features = n_features
        self.model = None
        self.scaler = StandardScaler()
        self.is_trained = False

    def build_model(self):
        inputs = Input(shape=(self.sequence_length, self.n_features))

        # Bidirectional LSTM layers
        bilstm1 = Bidirectional(LSTM(128, return_sequences=True, dropout=0.2))(inputs)
        bilstm1_norm = LayerNormalization()(bilstm1)

        bilstm2 = Bidirectional(LSTM(64, return_sequences=True, dropout=0.2))(bilstm1_norm)
        bilstm2_norm = LayerNormalization()(bilstm2)

        # Multi-head attention
        attention = MultiHeadAttention(num_heads=8, key_dim=64, dropout=0.1)(bilstm2_norm, bilstm2_norm)
        attention_norm = LayerNormalization()(attention)

        # Combine and pool
        combined = Concatenate()([bilstm2_norm, attention_norm])
        pooled = GlobalAveragePooling1D()(combined)

        # Dense layers
        dense1 = Dense(128, activation='relu')(pooled)
        dropout1 = Dropout(0.3)(dense1)
        dense2 = Dense(64, activation='relu')(dropout1)
        dropout2 = Dropout(0.2)(dense2)

        # Output layer for valence and arousal
        outputs = Dense(2, activation='tanh', name='affect_output')(dropout2)

        self.model = Model(inputs=inputs, outputs=outputs)
        self.model.compile(optimizer=Adam(learning_rate=0.001), loss='mse', metrics=['mae'])

        return self.model

    def prepare_sequences(self, X, y=None):
        X_sequences = []
        y_sequences = [] if y is not None else None

        for i in range(len(X) - self.sequence_length + 1):
            X_sequences.append(X.iloc[i:i+self.sequence_length].values)
            if y is not None:
                y_sequences.append(y.iloc[i+self.sequence_length-1].values)

        return np.array(X_sequences), np.array(y_sequences) if y is not None else None

    def train(self, X, y, epochs=50, batch_size=32):
        # Scale features
        X_scaled = pd.DataFrame(self.scaler.fit_transform(X), columns=X.columns, index=X.index)

        # Prepare sequences
        X_seq, y_seq = self.prepare_sequences(X_scaled, y)

        # Build model if not exists
        if self.model is None:
            self.build_model()

        # Callbacks
        callbacks = [
            EarlyStopping(patience=10, restore_best_weights=True, monitor='val_loss'),
            ReduceLROnPlateau(factor=0.5, patience=5, min_lr=1e-6, monitor='val_loss')
        ]

        # Train
        history = self.model.fit(
            X_seq, y_seq, validation_split=0.2, epochs=epochs,
            batch_size=batch_size, callbacks=callbacks, verbose=1
        )

        self.is_trained = True
        return history

    def predict(self, X):
        # X is 3D array with shape (samples, sequence_length, features)
        original_shape = X.shape
        X_flat = X.reshape(-1, original_shape[-1])
        X_scaled_flat = self.scaler.transform(X_flat)
        X_scaled = X_scaled_flat.reshape(original_shape)
        return self.model.predict(X_scaled)

class DreamBankPromptGenerator:
    def __init__(self, dreambank_processor):
        self.dreambank = dreambank_processor

    def generate_prompt_from_affect(self, valence, arousal, physiology_dict):
        # Find similar dreams from DreamBank
        similar_dreams = self.dreambank.find_similar_dreams(valence, arousal, n_dreams=3)

        if len(similar_dreams) == 0:
            return self.generate_fallback_prompt(valence, arousal, physiology_dict)

        # Extract elements from similar dreams
        all_elements = {
            'emotions': [],
            'settings': [],
            'characters': [],
            'activities': [],
            'colors': [],
            'themes': []
        }

        example_texts = []

        for _, dream in similar_dreams.iterrows():
            # Collect elements
            for key in all_elements.keys():
                all_elements[key].extend(dream[key])

            # Collect example text snippets
            text = dream['clean_text']
            if len(text) > 100:
                example_texts.append(text[:200] + "...")

        # Get top elements
        top_elements = {}
        for key, values in all_elements.items():
            if values:
                counter = Counter(values)
                top_elements[key] = [item[0] for item in counter.most_common(3)]
            else:
                top_elements[key] = ['neutral']

        # Determine visual style based on affect
        if valence > 0.3 and arousal > 0.3:
            style = "bright, vivid, energetic, joyful atmosphere"
            colors = "vibrant colors, warm lighting, golden tones"
        elif valence > 0.3 and arousal < -0.3:
            style = "peaceful, serene, harmonious, gentle atmosphere"
            colors = "soft pastels, natural lighting, calming tones"
        elif valence < -0.3 and arousal > 0.3:
            style = "dramatic, intense, dynamic, high-contrast atmosphere"
            colors = "bold colors, sharp contrasts, dramatic lighting"
        elif valence < -0.3 and arousal < -0.3:
            style = "melancholic, subdued, introspective, quiet atmosphere"
            colors = "muted colors, soft shadows, twilight tones"
        else:
            style = "balanced, realistic, everyday atmosphere"
            colors = "natural color palette, even lighting"

        # Generate comprehensive prompt
        prompt = f"""=== DREAMBANK-INSPIRED VISUAL PROMPT ===

CORE DREAM NARRATIVE (from DreamBank):
Based on similar dreams with valence={valence:.3f}, arousal={arousal:.3f}

EXTRACTED ELEMENTS:
• Primary Emotions: {', '.join(top_elements['emotions'][:3])}
• Settings/Locations: {', '.join(top_elements['settings'][:3])}
• Characters: {', '.join(top_elements['characters'][:2])}
• Key Activities: {', '.join(top_elements['activities'][:2])}
• Dominant Themes: {', '.join(top_elements['themes'][:2])}

VISUAL STYLE:
• Atmosphere: {style}
• Color Palette: {colors}
• Mood: {"Positive" if valence > 0 else "Negative"}, {"High Energy" if arousal > 0 else "Low Energy"}

PHYSIOLOGICAL INFLUENCES:
• REM Activity: {physiology_dict.get('rem_bursts', 0):.1f}
• Heart Rate: {physiology_dict.get('heart_rate_bpm', 70):.1f} bpm
• Brain Waves: Gamma {physiology_dict.get('eeg_gamma_power', 0):.3f}

EXAMPLE DREAMBANK EXCERPTS:
{chr(10).join([f"• {text[:100]}..." for text in example_texts[:2]])}

FINAL IMAGE PROMPT:
Create a dreamlike scene featuring {', '.join(top_elements['settings'][:2])} with {', '.join(top_elements['characters'][:2])}.
The scene shows {', '.join(top_elements['activities'][:2])} with an overall {style}.
Use {colors} and convey emotions of {', '.join(top_elements['emotions'][:2])}.
Style: surreal, dreamlike, cinematic, high detail, photographic quality
Themes: {', '.join(top_elements['themes'][:2])}
"""

        return prompt

    def generate_fallback_prompt(self, valence, arousal, physiology_dict):
        return f"""=== FALLBACK DREAM PROMPT ===
Predicted Affect: Valence={valence:.3f}, Arousal={arousal:.3f}
Create a dreamlike scene reflecting the emotional state.
REM: {physiology_dict.get('rem_bursts', 0):.1f}, HR: {physiology_dict.get('heart_rate_bpm', 70):.1f}
Style: surreal, atmospheric, dream photography"""

class CompleteDreamSystem:
    def __init__(self):
        self.physiological_df = None
        self.dreambank_loader = None
        self.dreambank_processor = None
        self.bilstm_model = None
        self.prompt_generator = None
        self.physiology_features = []

    def initialize_system(self, physiological_data_path):
        self.physiological_df = pd.read_csv(physiological_data_path)
        object_columns = ['valence', 'arousal']
        for col in object_columns:
            if col in self.physiological_df.columns:
                self.physiological_df[col] = self.physiological_df[col].astype(str).str.lower().str.strip()
                mapping = {
                    'low': 0, 'medium': 1, 'high': 2,
                    'negative': -1, 'neutral': 0, 'positive': 1,
                    'calm': 0, 'aroused': 1,
                }
                self.physiological_df[col] = self.physiological_df[col].replace(mapping)
                self.physiological_df[col] = pd.to_numeric(self.physiological_df[col], errors='coerce')

        self.physiological_df = self.physiological_df.fillna(self.physiological_df.median(numeric_only=True))
        print(f"Loaded {len(self.physiological_df)} physiological records")

        # 2. Load DreamBank dataset
        self.dreambank_loader = DreamBankLoader()
        dreambank_df = self.dreambank_loader.download_dreambank_data()

        if dreambank_df is None:
            print("Failed")
            return False

        # 3. Process DreamBank dreams
        self.dreambank_processor = DreamBankProcessor(dreambank_df)
        self.dreambank_processor.process_dreams()

        # 4. Initialize BiLSTM model
        self.physiology_features = [
            'eeg_theta_power', 'eeg_gamma_power', 'eeg_delta_power',
            'heart_rate_bpm', 'hrv_ms', 'rem_bursts', 'chin_emg',
            'respiration_rate', 'resp_irregularity', 'skin_conductance'
        ]

        available_features = [col for col in self.physiology_features if col in self.physiological_df.columns]
        self.physiology_features = available_features

        self.bilstm_model = BiLSTMDreamPredictor(
            sequence_length=10,
            n_features=len(available_features)
        )

        # 5. Initialize prompt generator
        self.prompt_generator = DreamBankPromptGenerator(self.dreambank_processor)

        print(f"System initialized with {len(available_features)} physiological features")
        print(f"DreamBank contains {len(self.dreambank_processor.processed_dreams)} processed dreams")

        return True

    def train_system(self, epochs=50, batch_size=32):
        # Prepare training data
        X = self.physiological_df[self.physiology_features].apply(pd.to_numeric, errors='coerce').fillna(0)
        y = self.physiological_df[['valence', 'arousal']].apply(pd.to_numeric, errors='coerce').fillna(0)

        print(f"Training data shape: X={X.shape}, y={y.shape}")

        # Train the model
        history = self.bilstm_model.train(X, y, epochs=epochs, batch_size=batch_size)

        # Evaluate model
        X_scaled = pd.DataFrame(
            self.bilstm_model.scaler.transform(X),
            columns=X.columns, index=X.index
        )
        X_seq, y_seq = self.bilstm_model.prepare_sequences(X_scaled, y)
        X_train, X_test, y_train, y_test = train_test_split(X_seq, y_seq, test_size=0.2, random_state=42)

        predictions = self.bilstm_model.model.predict(X_test)

        for i, target in enumerate(['valence', 'arousal']):
            mse = mean_squared_error(y_test[:, i], predictions[:, i])
            r2 = r2_score(y_test[:, i], predictions[:, i])
            print(f"{target}: MSE={mse:.4f}, R2={r2:.4f}")

        return history

    def generate_dreambank_prompt(self, physiology_sequence):

        # Predict affect from physiology
        predicted_affect = self.bilstm_model.predict(physiology_sequence.reshape(1, -1, len(self.physiology_features)))
        valence, arousal = predicted_affect[0][0], predicted_affect[0][1]

        # Create physiology dictionary
        physiology_dict = dict(zip(self.physiology_features, physiology_sequence[-1]))

        # Generate prompt using DreamBank
        dream_prompt = self.prompt_generator.generate_prompt_from_affect(valence, arousal, physiology_dict)

        return {
            'predicted_valence': valence,
            'predicted_arousal': arousal,
            'physiology_features': physiology_dict,
            'dreambank_prompt': dream_prompt
        }

    def analyze_dreambank_coverage(self):

        dreams = self.dreambank_processor.processed_dreams

        print(f"Total dreams processed: {len(dreams)}")
        print(f"Average valence: {dreams['mood_valence'].mean():.3f} (std: {dreams['mood_valence'].std():.3f})")
        print(f"Average arousal: {dreams['mood_arousal'].mean():.3f} (std: {dreams['mood_arousal'].std():.3f})")

        # Quadrant analysis
        quadrants = {
            'High Valence, High Arousal': ((dreams['mood_valence'] > 0.2) & (dreams['mood_arousal'] > 0.2)).sum(),
            'High Valence, Low Arousal': ((dreams['mood_valence'] > 0.2) & (dreams['mood_arousal'] < -0.2)).sum(),
            'Low Valence, High Arousal': ((dreams['mood_valence'] < -0.2) & (dreams['mood_arousal'] > 0.2)).sum(),
            'Low Valence, Low Arousal': ((dreams['mood_valence'] < -0.2) & (dreams['mood_arousal'] < -0.2)).sum(),
            'Neutral': ((abs(dreams['mood_valence']) <= 0.2) & (abs(dreams['mood_arousal']) <= 0.2)).sum()
        }

        print("\nDream distribution by affect quadrants:")
        for quadrant, count in quadrants.items():
            percentage = (count / len(dreams)) * 100
            print(f"  {quadrant}: {count} dreams ({percentage:.1f}%)")

        # Most common elements
        print("\nMost common dream elements:")
        all_emotions = []
        all_settings = []
        all_themes = []

        for _, dream in dreams.iterrows():
            all_emotions.extend(dream['emotions'])
            all_settings.extend(dream['settings'])
            all_themes.extend(dream['themes'])

        print("  Top emotions:", [item[0] for item in Counter(all_emotions).most_common(5)])
        print("  Top settings:", [item[0] for item in Counter(all_settings).most_common(5)])
        print("  Top themes:", [item[0] for item in Counter(all_themes).most_common(5)])

    def save_system(self, filepath="dreambank_bilstm_system.pkl"):
        save_data = {
            'model_weights': self.bilstm_model.model.get_weights() if self.bilstm_model.model else None,
            'scaler': self.bilstm_model.scaler,
            'physiology_features': self.physiology_features,
            'processed_dreams': self.dreambank_processor.processed_dreams,
            'dream_vectors': self.dreambank_processor.dream_vectors,
            'vectorizer': self.dreambank_processor.vectorizer,
            'is_trained': self.bilstm_model.is_trained
        }

        with open(filepath, 'wb') as f:
            pickle.dump(save_data, f)

def generate_sample_scripts(dream_system, n_samples=5):
    # Prepare test data
    X = dream_system.physiological_df[dream_system.physiology_features].apply(pd.to_numeric, errors='coerce').fillna(0)
    X_scaled = pd.DataFrame(
        dream_system.bilstm_model.scaler.transform(X),
        columns=X.columns, index=X.index
    )
    X_seq, _ = dream_system.bilstm_model.prepare_sequences(X_scaled)

    sample_scripts = []

    for i in range(min(n_samples, len(X_seq))):
        sample_sequence = X_seq[i]

        # Convert back to original scale for interpretation
        sample_orig = dream_system.bilstm_model.scaler.inverse_transform(
            sample_sequence.reshape(-1, len(dream_system.physiology_features))
        ).reshape(sample_sequence.shape)

        # Generate prompt
        result = dream_system.generate_dreambank_prompt(sample_orig)

        sample_scripts.append({
            'sample_id': i + 1,
            'valence': result['predicted_valence'],
            'arousal': result['predicted_arousal'],
            'physiology': result['physiology_features'],
            'prompt': result['dreambank_prompt']
        })

    return sample_scripts

def save_dreambank_scripts(scripts, filename="dreambank_generated_prompts.txt"):
    with open(filename, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\n")
        f.write("=" * 80 + "\n\n")

        for script_data in scripts:
            f.write(f"DREAM PROMPT #{script_data['sample_id']}\n")
            f.write("-" * 60 + "\n")
            f.write(f"Predicted Affect: Valence={script_data['valence']:.3f}, Arousal={script_data['arousal']:.3f}\n")
            f.write(f"Key Physiology: REM={script_data['physiology'].get('rem_bursts', 0):.1f}, ")
            f.write(f"HR={script_data['physiology'].get('heart_rate_bpm', 70):.1f}bpm\n")
            f.write("-" * 60 + "\n\n")
            f.write(script_data['prompt'])
            f.write("\n" + "=" * 80 + "\n\n")
    return filename

def main():
    print("=" * 60)

    # Initialize system
    dream_system = CompleteDreamSystem()

    physiological_data_path = "dreamwave_synthetic_sleep1.csv"

    success = dream_system.initialize_system(physiological_data_path)

    if not success:
        print("failed!")
        return None

    # Analyze DreamBank coverage
    dream_system.analyze_dreambank_coverage()

    # Train the BiLSTM model
    print("\n" + "=" * 60)
    history = dream_system.train_system(epochs=50, batch_size=32)

    # Generate sample scripts
    print("\n" + "=" * 60)
    sample_scripts = generate_sample_scripts(dream_system, n_samples=5)

    # Save scripts
    script_filename = save_dreambank_scripts(sample_scripts)

    # Save complete system
    dream_system.save_system("dreambank_bilstm_system.pkl")
    return dream_system, sample_scripts

def load_custom_dreambank(filepath):
    dream_system = CompleteDreamSystem()
    dream_system.dreambank_loader = DreamBankLoader()

    dreambank_df = dream_system.dreambank_loader.load_dreambank_from_file(filepath)

    if dreambank_df is not None:
        dream_system.dreambank_processor = DreamBankProcessor(dreambank_df)
        dream_system.dreambank_processor.process_dreams()
        return dream_system
    else:
        print("Failed to load custom DreamBank file")
        return None

def interactive_prompt_generation(dream_system):
    if not dream_system.bilstm_model.is_trained:
        return
    print("Enter physiological values or 'quit' to exit")

    while True:
        try:
            user_input = input("\nEnter 'random' for random values or 'quit': ").strip().lower()

            if user_input == 'quit':
                break
            elif user_input == 'random':
                # Generate random physiological sequence
                n_features = len(dream_system.physiology_features)
                sequence_length = 10

                # Create realistic random values
                random_sequence = np.random.randn(sequence_length, n_features)
                random_sequence[:, 0] *= 0.5 # EEG theta
                random_sequence[:, 1] *= 0.3 # EEG gamma
                random_sequence[:, 3] = 70 + random_sequence[:, 3] * 15 # Heart rate around 70

                result = dream_system.generate_dreambank_prompt(random_sequence)

                print(f"\nGenerated Dream Prompt:")
                print(f"Valence: {result['predicted_valence']:.3f}")
                print(f"Arousal: {result['predicted_arousal']:.3f}")
                print("\n" + "="*50)
                print(result['dreambank_prompt'][:500] + "\n[... truncated ...]")
                print("="*50)
            else:
                print("Please enter 'random' or 'quit'")

        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"Error: {str(e)}")

    print("Interactive session ended")

if __name__ == "__main__":
    dream_system, sample_scripts = main()

    if dream_system and sample_scripts:
        print("\n" + "="*60)
        interactive_choice = input("Run interactive prompt generation? (y/n): ").strip().lower()
        if interactive_choice == 'y':
            interactive_prompt_generation(dream_system)

        print("\nThank you for using the DreamBank-BiLSTM Dream Generation System!")
    else:
        print("\n System failed to initialize. Please check your datasets.")



import os
file_path = "/content/dreambank_bilstm_system.pkl"
if os.path.exists(file_path):
    print(f"File found at: {file_path}")
    from google.colab import files
    try:
        files.download(file_path)
        print("Attempting to download the file...")
    except Exception as e:
        print(f"An error occurred during download: {e}")
        print("Please try downloading manually from the file explorer on the left.")
else:
    print(f"File not found at: {file_path}")